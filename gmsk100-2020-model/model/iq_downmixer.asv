function complex_envelope = iq_downmixer(signal, osr, br, fc, fs)

% TODO: You may want to implement a better downsampling filter.
[nbrows, nbcols] = size(signal);
for k=1:nbcols
    % IQ downmixer
    t = ((1 : numel(signal(:,k)))' - 1) / fs;
    cordic = 0;
    if cordic
        cos = zeros(length(t), 1);
        sin = zeros(length(t), 1);
        for i =1:length(t)
            v = cordic(2 * pi * fc *t(i),6);
            cos(i) = v(1);
            sin(i) = v(2);
        end
    else
        
    end
    upsampled_envelope_Q = cos .* signal(:,k);
    upsampled_envelope_I = sin .* signal(:,k);

    % apply a simple downsampling filter
%     filt = ones(2 * round(fs / (br * osr)) + 1)     ;


    % This is simply a crude block filter, use a matched filter instea,
    % this means instead of our impulse response being a series of ones our
    % impulse response should be the pulse shape.
    %plot shape:
    plot(upsampled_envelope_Q)
    
    
    filt = ones(2 * round(fs / (br *     osr)) + 1); 
    % elements in a pulse = time in a pulse / time in a pulse per element
    % = 1/br / 
    upsampled_envelope = conv(upsampled_envelope, filt / sum(filt), 'same');

    % calculate number of output samples
    n1 = numel(upsampled_envelope);
    n2 = round((n1 - 1) * (br * osr) / fs) + 1;

    % resample the complex envelope to the new sample rate
    t1 = ((1 : n1)' - 1) / fs;
    t2 = ((1 : n2)' - 1) / (br * osr);
    complex_envelope(:,k) = interp1(t1, upsampled_envelope, t2);
end

end